\chapter{Background}
\label{Background}
\textit{The chapter starts with a general description about \textit{\nameref{WebApplication}} structure and is followed a presentation of the \textit{\nameref{cia}} commonly used when discussing security. It is followed by a section about web applications \textit{\nameref{SecurityVulnerabilities}}. Followed by two sections describing \textit{\nameref{DynamicTaintTracking}} and the programming language \textit{\nameref{JavaInstrumentation}}.}



\section{Web Application}
\label{WebApplication}
To make applications available and accessible from now days almost everywhere do companies deploy their applications on the web. The deployment of an application can vary a lot, but the most common structure for a web application is based on a three-tier architecture as illustrated in Figure \ref{fig:webApplication-Haldar}. The first tier is the presentation tier which contains the visual components rendered by the browser. Logic tier is the second and contains the applications business logic. The third tier is the storage, where the business logic stores data as needed \parencite{JustinClarke-Salt2009SIAa}.
 
\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{images/webApplication-Haldar.png}
  \caption{An illustration of the three-tier architecture commonly used by web applications \cite{Haldar}.}
  \label{fig:webApplication-Haldar}
\end{figure}

From Figure \ref{fig:webApplication-Haldar} it can be seen that tiers only communicate with the tiers closest to themselves. This causes the logic tier to become a safeguard for the storage tier where valuable and possibly sensitive information is stored. The sensitive information might, for example, be users name, email, personal security numbers and credit card information \parencite{JustinClarke-Salt2009SIAa}.

The scope of the thesis lies in the logic tier where both trusted and untrusted data is processed, and validations are needed to ensure secure applications. The programming language for the logic tier can vary a lot, but one common and the chosen language for this thesis is Java.



\subsection{Structured Query Language}
Communication between the logic and storage tier is done through a standardized language called Structured Query Language, mostly known as SQL. SQL is created to manipulate and access databases programmatically. The majority of today's database uses SQL. The language works by building queries specifying the required information or task. The query is then evaluated and handled up upon by the SQL engine \parencite{DarieCristian2003TPGt}.



\section{CIA Triad}
\label{cia}
Discussions regarding information security often rely on the CIA Triad. CIA stands for confidentiality, integrity, and availability as displayed in Figure \ref{fig:CIATriad}. Confidentiality ensures data usage by only authorized individuals. Integrity specifies that application data should be accurate and unaltered. Availability is the ability to access the application and application data \parencite{2014C1-W}.

\begin{figure}[H]
    \centering
    \includegraphics[height=6cm]{images/CIATriad.jpg}
    \caption{An illustration of the CIA Triad, model used when discussing information security.}
    \label{fig:CIATriad}
\end{figure}



\section{Security Vulnerabilities}
\label{SecurityVulnerabilities}
The organization Open Web Applications Security Project, known as OWASP, is an online community which aims to provide knowledge on how to secure web applications \parencite{OpenWebApplicationSecurityProject}. OWASP has produced reports about the top ten security risks for web applications, and the latest was published in 2017. The report contains information about the ten most common security risks for the given year. Information such as how the security risk is exploited and possible prevention methods are also presented. This thesis will look at security risk number one and seven from the latest report. These two security risks are vulnerabilities of information disclosure and code injection. The two vulnerabilities are Injection attack and Cross-Site Scripting \parencite{OWASP2017}.



\subsection{SQL Injection Attacks}
The most common security risk is Injection Attacks \parencite{OWASP2017}. Injection Attack is an attack where the attacker's input changes the intent of the execution. The typical results of Injection Attacks are file destruction, lack of accountability, denial of access and data loss \parencite{Secure_Web}.

Injection Attacks exists towards a broad set of different areas but the area discussed and analyzed in this thesis is SQL Injections. SQL Injections can be divided into two different subgroups. These two subgroups are SQL Injection and Blind SQL Injection \parencite{Secure_Web}.



\subsubsection{SQL Injection}
SQL Injection occurs when an SQL query is tampered with which results in gaining content or executing a command on the database which was not intended. Listing \ref{lst:acceptable_to_SQL_Injection} displays an SQL query which is open to SQL Injections. This is because the variable UserId is never validated before it is propagated into the query \parencite{JustinClarke-Salt2009SIAa, Secure_Web}.

\hfill
\begin{lstlisting}[
  language=SQL,
  caption=Pseudo code acceptable to SQL Injection through malicious usage of \textit{userInput}.,
  label={lst:acceptable_to_SQL_Injection}]
userId = (*@\textit{userInput}@*)
"SELECT * FROM Users WHERE userId = " + userId
\end{lstlisting}
\hfill

The query work as intended if the user input, labeled as \textit{userInput}, is a valid Integer (since Integer is what we have decided that user id is in the application). An example of malicious usage of user input is \textit{10 or 1 = 1}. This input would result in the query seen in Listing \ref{lst:SQL_Injection}.

\hfill
\begin{lstlisting}[
  language=SQL,
  caption=An example of SQL Injection where the whole Users table is returned,
  label={lst:SQL_Injection}]
SELECT * FROM Users WHERE userId = 10 or 1 = 1
\end{lstlisting}
\hfill

This query results in an execution that always evaluates to true. As a result the query returns the whole table of users. This problem can be prevented in different ways. The first is through validation of input. By verifying user input as in Listing \ref{lst:SQL_Injection_Verified} can we protect the query from being vulnerable to the SQL Injection.

\hfill
\begin{lstlisting}[
  language=SQL,
  caption=An example of SQL Injection prevention through variable sanitiazion.,
  label={lst:SQL_Injection_Verified}]
userId = (*@\textit{userInput}@*)
isInteger(userId)
"SELECT * FROM Users WHERE userId = " + userId
\end{lstlisting}
\hfill

A second common alternative is to use SQL Parameters which handle the verification for the user. This leaves the verification and validation of input up to the SQL engine. An example written with SQL Parameters can be seen in Listing \ref{lst:SQL_Injection_Parameters}.

\hfill
\begin{lstlisting}[
  language=SQL,
  caption=An example of SQL Injection prevention through SQL Parameters.,
  label={lst:SQL_Injection_Parameters}]
userId = (*@\textit{userInput}@*)
sqlQuery = "SELECT * FROM Users WHERE userId = @0"
db.Execute(sqlQuery, userId)
\end{lstlisting}



\subsubsection{Blind SQL Injection}
Blind SQL Injection is very similar to SQL Injection. The only difference is that the attacker does not receive the requested information in clear text from the database. The information is instead received by monitoring variables such as how long time the response takes or what kind of error messages it returns. An example of the first is an SQL query that tells the SQL engine to sleep depending on a condition. An example of this can be seen in Listing \ref{lst:Blind_SQL_Injection_Time} \parencite{JustinClarke-Salt2009SIAa, Secure_Web}.

\hfill
\begin{lstlisting}[
  language=SQL,
  caption=An example of Blind SQL Injection where query response is delayed five seconds if a user with id one is in the Users table.,
  label={lst:Blind_SQL_Injection_Time}]
SELECT * FROM Users WHERE userId = 1 WAITFOR DELAY '0:0:5'
\end{lstlisting}
\hfill

The second variant of a Blind SQL Injection is through analyzing error messages and, depending on what they return, build an image of the targeted data. This is mostly done through testing different combinations of true and false queries \parencite{JustinClarke-Salt2009SIAa, Secure_Web}.



\subsection{Cross-Site Scripting}
Cross-Site Scripting has been a vulnerability since the introduction of JavaScript in websites. One of the first Cross-Site Scripting attacks was created just after the release of JavaScript. The attack was conducted through loading a malicious web application into a frame on the site that the attacker wants to gain access to. The attacker could then through JavaScript access any content that is visible or typed into the web application. Same-Origin Policy was introduced to prevent this form of attack. The policy restricts JavaScript to only access content from its origin \parencite{FogieSeth2007Xacs, w3csop}.

The introduction of the Same-Origin Policy, however, did not stop the attackers. The next wave of attacks was mostly towards chat rooms where it was possible to inject malicious Cross-Site Scripts into the input of the message. Which would then be reflected by the server itself, when displaying the message for other users, and thereby bypassing the Same-Origin Policy \parencite{FogieSeth2007Xacs}.

There are three different types of Cross-Site Scripting. These three are reflected, stored, and DOM-based Cross-Site Scripting.



\subsubsection{Reflected Cross-Site Scripting}
Reflected Cross-Site Scripting, mostly conducted through a malicious link that an user accesses. The malicious link will exploit a vulnerable input on the targeted web application and through the input reflect back malicious content to the user \parencite{Secure_Web}.



\subsubsection{Stored Cross-Site Scripting}
Stored Cross-Site Scripting is when malicious scripts get stored in the targeted web applications database. This malicious script is then loaded and presented to each user who is trying to access the application \parencite{Secure_Web}.



\subsubsection{DOM-based Cross-Site Scripting}
DOM-based Cross-Site Scripting is very similar to Reflected Cross-Site Scripting, but it does not necessarily have to be reflected from the application server. DOM-based Cross-Site Scripting modifies the DOM tree and through that it exploits the user \parencite{Secure_Web}.



\section{Taint Tracking}
\label{DynamicTaintTracking}
Taint tracking, also known as taint analysis, taint checking and taint propagation, is a tool to analyze the flow of information in a domain \parencite{Pan2015}. The goal of taint tracking is to prevent possible attacks such as Injection and Cross-Site Scripting by enforcing the usage of sanitizers on input data. Taint tracking is possible to execute in two different forms: static and dynamic. The static is an evaluation tool which is done statically before runtime. Dynamic is an application that executes at runtime. There are pros and cons for both versions. The pros for static is the usability in the integrated development environment, and the pros for dynamic is a higher accuracy of taint propagation. 

Taint trackers operate by tracking data and acting upon any that are trying to enter sinks without first been detainted through sanitation. Perl and Ruby are two programming languages which have adapted to use taint checking \parencite{perl, ruby}. There are some tools which enable taint checking for other platforms. TaintDroid \parencite{Ma2010} for the Android platform is one of them. This thesis will handle dynamic taint tracking and how it can increase the security of Java-based web applications.

Taint tracking contains four main tasks which are described in Table \ref{table:taintTracking}. The first is marking all data from sources as tainted. This is done through a taint flag attached to the input variables. This taint flag follows the input, which is the second task, throughout the application and propagates onto any other data it encounters. The third task is the possibility of detainting data, but this is only done after the data have been sanitized through predefined sanitizers. The fourth and last task is checking the taint flags in areas called sinks which are entry points to sensitive code \parencite{Pan2015, Venkataramani2008}. The decision of what to do if a tainted variable tries to pass through a sink vary depending on the application, however, remedial actions should be conducted. These actions should be, depending on the application owners choice, logging events, throwing errors, or modifying the tainted values into safe predefined values. 

\begin{table}[H]
  \centering
  \caption{Core logic behind taint tracking}
  \label{table:taintTracking}
  \begin{description}
    \item [Tainting] Marking all data from sources as tainted.
    \item [Propagat Taint] Propagating taint to all data coming in contact with tainted data.
    \item [Detainting] Marking all data from sanitizers as non-tainted.
    \item [Assert Non-tainted] Assert that data passing through sinks are non-tainted. 
  \end{description}
\end{table}

An example of taint tracking can be seen in Listing \ref{lst:taint_propagation}. In this example \textit{getAttribute} is a source, \textit{executeQuery} a sink and \textit{validate} a sanitizer. On row one, the input from the source is flagged tainted, and the taint propagates onto \textit{userId}. The sanitizer on row two validates \textit{userId} and removes the tainted flag. Lastly, the sink on row three executes the query since the argument is not tainted. If a user sends in a malicious userId containing "101 OR 1 = 1" the validator would sanitize the String and safely execute the sink command. However, removing line two would result in tainted data entering the sink. This would without a dynamic taint tracker result in giving the malicious user the entire list of Users. With a dynamic taint tracker, however, the result is the sink halting the execution, therefore, preventing unwanted information disclosure.

\hfill
\begin{lstlisting}[
  caption=Taint Tracking,
  numbers=left,
  label={lst:taint_propagation}]
userId = getAttribute("userId");
validate(userId)
executeQuery("SELECT * FROM Users WHERE userId = " + userId);
\end{lstlisting}
\hfill



\section{Java}
\label{JavaInstrumentation}
Java has been around since the early 90's. The founder's objective was to develop a new improved programming language that simplified the task for the developer but still had a familiar C/C++ syntax. \parencite{OracleVoice}. Today is Java one of the most common programming languages \parencite{octoverse}.

Java is a statically typed language which means that no variable can be used before being declared. These variables can be of two different types: primitives and reference to objects. Among the primitives does Java have support for eight. These are byte, short, int, long, float, double, boolean and char \parencite{primjav}.



\subsection{Java Virtual Machine}
There exists a plethora of implementation of the Java Virtual Machine, but the official that Oracle develop is HotSpot \parencite{hotSpot}. One of the core ideas with Java during its development was "Write once, run anywhere." The slogan was created by Sun Microsystems which at the time were the company behind Java and the Java Virtual Machine. \parencite{Craig_2006}. The idea behind the Java Virtual Machine was to enable one language to execute the same on all platforms and then modify the Java Virtual Machine to be able to run on as many platforms as possible. The Java Virtual Machine is a virtual machine with its own components of heap storage, stack, program counter, method area, and runtime constant pool.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/JvmSpec7.png}
    \caption{Java Virtual Machine Architecture}
    \label{fig:JVM}
\end{figure}

Figure \ref{fig:JVM} illustrates the architecture of the Java Virtual Machine. The ClassLoader loads the compiled Java code and adds it into the Java Virtual Machine Memory. The logic behind Java instrumentation lies in the ClassLoader. The ClassLoader will trigger the implemented Java Agent and allow for instrumentation of each class file before being loaded into the Java Virtual Machine \parencite{venners_1999, instru}.



\subsection{Instrumentation}
Java instrumentation is a way to modify the execution of an application without knowing nor the need of modifying the application code itself. Good use cases for Java instrumentation is, for example, monitoring agents, event loggers, and taint trackers. Instrumentation is an official Java package that provides services needed to modify the bytecode of program executions. It is conducted through implementing an Agent that will have the possibility to transform every class loaded by the ClassLoader before being used for the first time. Transformation of class files are on bytecode level, but there exist libraries that can help in this task. One of these libraries and the one used in this thesis is Javassist \parencite{Java_Instrument, Javassist}.

There are some restrictions to instrument classes during runtime. Classes needed for the Java Virtual Machine need transformation before executing the Java application. This is because those classes load before and are needed by the instrumentation agent. These classes are the content of the base Java Runtime Environment in the rt.jar.



\subsection{Javassist}
There exist several libraries that can help the developer in the task of creating an instrumentation Agent. The help comes in libraries of high-level functions that later translates into bytecode that the Java Virtual Machine understands. The library used in this thesis is Javassist. Javassist stands for Java programming Assistant and is a bytecode engineering toolkit. Javassist provides two levels of API where the one used in this thesis provides the functionality of editing class files on source level which require no understanding of Java bytecode \parencite{Javassist}.