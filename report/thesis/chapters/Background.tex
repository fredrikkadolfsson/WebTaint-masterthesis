\chapter{Background}
\todo[inline]{Todo: Uppdatera till senaste (SISTA SOM GÃ–RS)}
This Chapter will present background knowledge needed to comprehend the thesis. The chapter starts with a general description about \textit{\nameref{WebApplication}} structure and is followed by a section discussing common \textit{\nameref{SecurityVulnerabilities}} to web applications. After those follows two sections describing \textit{\nameref{DynamicTaintTracking}}. The last section is about the programing language \textit{\nameref{JavaInstrumentation}}.



\section{Web Application}
\label{WebApplication}
To make applications available for a broad set of people and make them accessible from now days almost everywhere do businesses deploy their applications on the web. The deployment of an application can vary a lot, but the most common structure for a web application is based on a three-tier architecture illustrated in Figure \ref{fig:webApplication-Haldar}. The first tier is the presentation tier which is the visual components rendered by the browser. The second is the logic tire which is the brain of the application. The last and third tier is the storage, where the second tier can store data as needed \parencite{JustinClarke-Salt2009SIAa}.

\begin{figure}[H]
  \centering
  \includegraphics[width=\textwidth]{images/webApplication-Haldar.png}
  \caption{The three-tier web application architecture \cite{Haldar}.}
  \label{fig:webApplication-Haldar}
\end{figure}

From Figure \ref{fig:webApplication-Haldar} can it be seen that tiers only communicate with the tire closest to themselves. This causes the second tier to become a safeguard for tier three where the valuable and possibly sensitive information is stored. This essential information is mostly needed for the application to provide its intended service. Such information might, for example, be name, email, personal number and credit card information \parencite{JustinClarke-Salt2009SIAa}.

The scope of the thesis lies in tier two where bought trusted and untrusted data is processed, and validations are needed to ensure secure applications. The programming language for tier two might vary a lot, but one common and the chosen language for this thesis is Java.



\subsection{Structured Query Language}
Communication between tier two and tier three is done through a standardized language called Structured Query Language, mostly known as SQL. SQL is created to manipulate and access databases programmatically. The clear majority of today's database uses SQL. The language works by building queries specifying the required information or task. The query will be evaluated and handled up upon by the SQL engine \parencite{DarieCristian2003TPGt}.



\section{CIA Triad}
\label{cia}
Discussions about application security rely on the CIA Triad which represents the three primary concepts in information security. These three are confidentiality, integrity, and availability and is seen in \ref{fig:CIATriad}. Confidentiality is rules that specify the access restrictions to the application. Integrity specifies that application data should be accurate and unaltered. Availability is about the ability to access the application and application data \parencite{2014C1-W}.

\begin{figure}[H]
    \centering
    \includegraphics[height=6cm]{images/CIATriad.jpg}
    \caption{CIA Triad}
    \label{fig:CIATriad}
\end{figure}



\section{Security Vulnerabilities}
\label{SecurityVulnerabilities}
The organization Open Web Applications Security Project, known as OWASP, is an online community which aims to provide knowledge how to secure web applications \parencite{OpenWebApplicationSecurityProject}. OWASP has produced reports about the top 10 security risks for web applications, and the latest was published in 2017. The report contains information about the ten most common security risks for the current year. Information such as how the security risk is exploited and possible prevention methods are also presented. This thesis will look at security risk number one and seven from the latest report. These vulnerabilities are two vulnerabilities towards integrity and are Injection attacks and Cross-Site Scripting \parencite{OWASP2017}.



\subsection{Injection Attack}
The most common security risk is Injection Attacks \parencite{OWASP2017}. Injection Attack is an attack where the attacker's input changes the intent of the execution. The typical results of Injection Attacks are file destruction, lack of accountability, denial of access and data loss \parencite{Secure_Web}.

Injection Attacks can be divided into two different subgroups. These two subgroups are SQL Injection and Blind SQL Injection \parencite{Secure_Web}.



\subsubsection{SQL Injection}
SQL Injection is when a SQL query is tampered with which results in gaining content or executing a command on the database which was not intended. Listing \ref{lst:acceptable_to_SQL_Injection} displays a SQL Query which is open to SQL Injections. This is because the variable UserId is never validated before it is propagated into the query \parencite{JustinClarke-Salt2009SIAa, Secure_Web}.

\hfill
\begin{lstlisting}[
  language=SQL,
  caption=Code Acceptable to SQL Injection,
  label={lst:acceptable_to_SQL_Injection}]
userId = (*@\textit{userInput}@*)
"SELECT * FROM Users WHERE userId = " + userId
\end{lstlisting}
\hfill

The query will work as intended if the user input, labeled as \textit{userInput}, is a valid Integer (since Integer is what we have decided that user id is in the application). But what happens if the user input is \textit{10 or 1 = 1}? This input would result in the query seen in Listing \ref{lst:SQL_Injection}.

\hfill
\begin{lstlisting}[
  language=SQL,
  caption=SQL Injection,
  label={lst:SQL_Injection}]
SELECT * FROM Users WHERE userId = 10 or 1 = 1
\end{lstlisting}
\hfill

This query results in an execution that always evaluates to true. The result of this will be that the query returns the whole table of users. This problem can be prevented in a couple of different ways. The first is through validation of input. By verifying user input as seen in Listing \ref{lst:SQL_Injection_Verified} can we protect the query from being vulnerable to SQL Injection.

\hfill
\begin{lstlisting}[
  language=SQL,
  caption=Preventing SQL Injection through Verification,
  label={lst:SQL_Injection_Verified}]
userId = (*@\textit{userInput}@*)
isInteger(userId)
"SELECT * FROM Users WHERE userId = " + userId
\end{lstlisting}
\hfill

A second common alternative is to use SQL Parameters which handles the verification for the user. This leaves the verification and validation of input up to the SQL engine. An example written with SQL Parameters can be seen in Listing \ref{lst:SQL_Injection_Parameters}.

\hfill
\begin{lstlisting}[
  language=SQL,
  caption=Preventing SQL Injection through SQL Parameters,
  label={lst:SQL_Injection_Parameters}]
userId = (*@\textit{userInput}@*)
sqlQuery = "SELECT * FROM Users WHERE userId = @0"
db.Execute(sqlQuery, userId)
\end{lstlisting}



\subsubsection{Blind SQL Injection}
Blind SQL Injection is very similar to SQL Injection. The only difference is that that attacker does not receive the requested information in clear text from the database. The information is instead received by monitoring variables such as how long time the response took or what kind of error messages it returns. An example of the first is a SQL query that tells the SQL engine to sleep depending on a condition. An example of this can be seen in Listing \ref{lst:Blind_SQL_Injection_Time} \parencite{JustinClarke-Salt2009SIAa, Secure_Web}.

\hfill
\begin{lstlisting}[
  language=SQL,
  caption=Time Based Blind SQL Injection,
  label={lst:Blind_SQL_Injection_Time}]
SELECT * FROM Users WHERE userId = 1 WAITFOR DELAY '0:0:5'
\end{lstlisting}
\hfill

The second variant of Blind SQL Injection is through analyzing error messages and depending on what they return, build an image of the targeted data. This is mostly done through testing different combinations of true and false queries \parencite{JustinClarke-Salt2009SIAa, Secure_Web}.



\subsection{Cross-Site Scripting}
Cross-Site Scripting has been a vulnerability since the beginning of the internet. One of the first Cross-Site Scripting attacks was created just after the release of JavaScript. The attack was conducted through loading a malicious web application into a frame on the site that the attacker wants to gain access to. The attacker could then through JavaScript access any content that is visible or typed into the web application. To prevent this form of attack where the standard of Same-Origin Policy introduced. Same-Origin Policy restricts JavaScript to only access content from its own origin \parencite{FogieSeth2007Xacs, w3csop}.

The introduction of the Same-Origin Policy, however, did not stop the attackers. The next wave of attacks was mostly towards chat rooms where it was possible to inject malicious Cross-Site Scripts into the input of the message. Which would then later be reflected by the server itself, when displaying the message for other users, and thereby bypassing the Same-Origin Policy \parencite{FogieSeth2007Xacs}.

Dividing Cross-Site Scripting into three different subcategories is possible. These three are reflected, stored, and DOM-based Cross-Site Scripting.



\subsubsection{Reflected Cross-Site Scripting}
Reflected Cross-Site Scripting, mostly conducted through a malicious link that an unknowing user accesses. The malicious link will exploit a vulnerable input on the targeted web application and through the input reflect back malicious content to the user \parencite{Secure_Web}.



\subsubsection{Stored Cross-Site Scripting}
Stored Cross-Site Scripting is when malicious scripts get stored in the targeted web applications database. This malicious script is then loaded and presented to each user who is trying to access the application \parencite{Secure_Web}.



\subsubsection{DOM-based Cross-Site Scripting}
DOM-based Cross-Site Scripting is very similar to Reflected Cross-Site Scripting, but it does not necessarily have to be reflected from the application server. DOM-based Cross-Site Scripting modifies the DOM tree and through that exploits the user \parencite{Secure_Web}.



\section{Taint Tracking}
\label{DynamicTaintTracking}
Taint tracking, also known as taint analysis, taint checking and taint propagation, is a tool to analyze the flow of information in a domain \parencite{Pan2015}. The goal of taint tracking is to prevent possible attacks such as Injection and Cross-Site Scripting by enforcing the usage of sanitizers on input data. Taint tracking is possible to execute in two different forms: static and dynamic. The static is an evaluation tool which is done statically before runtime. Dynamic is a tool that is executed at runtime. There are pros and cons for both versions. The pros for static is the usability in the integrated development environment, and the pros for dynamic is a higher propagating taint accuracy. 

Taint trackers operate by tracking data and actively blocking any that are trying to enter sinks without first been detainted through sanitation. Perl and Ruby are two programming languages which have adapted to use taint checking \parencite{perl, ruby}. There are some tools which enable taint checking for other platforms. TaintDroid \parencite{Ma2010} for the Android platform is one of them. This thesis will handle dynamic taint tracking and how it can increase the security of Java-based web applications.

Taint tracking contains four main tasks which are described in Table \ref{table:taintTracking}. The first is marking all data from sources as tainted. This is done through a taint flag attached to the input variables. This taint flag follows the input, which is the second task, throughout the application and propagates onto any other data it encounters. The third task, is the possibility to detaint data, but this is only done after the data have been sanitized through predefined sanitizers. Fourth and last task is checking the taint flags in areas called sinks which are entry points to sensitive code \parencite{Pan2015, Venkataramani2008}. The decision of what to do if a tainted variable tries to pass through a sink vary depending on the application, however, remedial actions should be conducted. These activities should be, depending on application owners choice, logging events, throwing errors, or modifying the tainted values into safe predefined values. 

\begin{table}[H]
  \centering
  \caption{Core logic behind taint tracking}
  \label{table:taintTracking}
  \begin{description}
    \item [Tainting] Marking all data from sources as tainted.
    \item [Propagat Taint] Propagating taint to all data coming in contact with tainted data.
    \item [Detainting] Marking all data from sanitizers as non-tainted.
    \item [Assert Non-tainted] Assert that data passing through sinks are non-tainted. 
  \end{description}
\end{table}

An example of taint tracking can be seen in Listing \ref{lst:taint_propagation}. In this example \textit{getAttribute} is a source, \textit{executeQuery} a sink and \textit{validate} a sanitizer. On row one, the input from the source is flagged tainted, and the taint propagates onto \textit{userId}. The sanitizer on row two validates \textit{userId} and removes the tainted flag. Lastly, the sink on row three executes the query since the argument is not tainted. If a user sends in a malicious userId containing "101 OR 1 = 1" the validator would sanitize the String and safely execute the sink command. However, removing line two would result in tainted data entering the sink. This would without a dynamic taint tracker result in giving the malicious user the entire list of Users. With a dynamic taint tracker, however, the result is the sink halting the execution, therefore, preventing unwanted information disclosure.

\hfill
\begin{lstlisting}[
  caption=Taint Tracking,
  numbers=left,
  label={lst:taint_propagation}]
userId = getAttribute("userId");
validate(userId)
executeQuery("SELECT * FROM Users WHERE userId = " + userId);
\end{lstlisting}
\hfill

The above described dynamic taint tracking tool focuses on preventing malicious code from entering and causing harm to the application. These represent security policies restricting input from sources to pass through sinks without first being sanitized through validation. The same application could be used to enforce policies restricting sensitive data to leave the system. It is done by marking access points to sensitive data as sources and unallowed exits of the system as sinks.



\section{Java}
\label{JavaInstrumentation}
Java has been around since the early 90's. The founder's objective was to develop a new improved programming language that simplified the task for the developer but still had a familiar C/C++ syntax. \parencite{OracleVoice}. Today is Java one of the most common programming languages \parencite{octoverse}.

Java is a statically typed language which means that no variable can be used before being declared. These variables can be of two different types: primitives and reference to objects. Among the primitives does Java have support for eight. These are byte, short, int, long, float, double, boolean and char \parencite{primjav}.



\subsection{Java Virtual Machine}
There exists a plethora of implementation of the Java Virtual Machine, but the official that Oracle develop is HotSpot \parencite{hotSpot}. One of the core ideas with Java during its development was "Write once, run anywhere." The slogan was created by Sun Microsystems which at the time were the company behind Java and the Java Virtual Machine. \parencite{Craig_2006}. The idea behind the Java Virtual Machine was to have one language that executed the same on all platforms and then modify the Java Virtual Machine to be able to run on as many platforms as possible. The Java Virtual Machine is a virtual machine with its own components of heap storage, stack, program counter, method area, and runtime constant pool.

\begin{figure}[H]
    \centering
    \includegraphics[width=\textwidth]{images/JvmSpec7.png}
    \caption{Java Virtual Machine Architecture}
    \label{fig:JVM}
\end{figure}

Figure \ref{fig:JVM} illustrates the architecture of the Java Virtual Machine. The ClassLoader loads the compiled Java code and adds it into the Java Virtual Machine Memory. The logic behind Java instrumentation lies in the ClassLoader. The ClassLoader will trigger the implemented Java Agent and allow for instrumentation of each Java file before being loaded into the Java Virtual Machine \parencite{venners_1999, instru}.



\subsection{Instrumentation}
Java instrumentation is a way to modify the execution of an application without knowing nor the need of modifying the application code itself. Good use cases for Java instrumentation is, for example, monitoring agents, and event loggers. Instrumentation is an official Java package that provides services needed to modify the bytecode of program executions. It is conducted through implementing an Agent that will have the possibility to transform every class loaded by the ClassLoader before being used for the first time. Transformation of class files are on bytecode level, but there exist libraries that can help in this task. One of these libraries and the one used in this thesis is Javassist \parencite{Java_Instrument, Javassist}.

There are some restrictions to instrument classes during runtime. Classes needed for the Java Virtual Machine need transformation before executing the Java application. This is because those classes load before the instrumentation agent. Those classes are the content of the base Java Runtime Environment in the rt.jar.



\subsection{Javassist}
There exist several libraries that can help the developer in the task of creating an instrumentation Agent. The help comes in libraries of high-level functions that later translates into bytecode that the Java Virtual Machine understands. The library used in this thesis is Javassist. Javassist stands for Java programming Assistant and is a bytecode engineering toolkit. Javassist provides two levels of API where the one used in this thesis provides the functionality of editing class files on source level which require no understanding of Java bytecode \parencite{Javassist}.