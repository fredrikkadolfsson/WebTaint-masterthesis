\chapter{Discussion}
\label{Discussion}
\textit{This chapter contains the discussions about the implemented dynamic taint tracker, named WebTaint, and how well it performs. The chapter starts with a general discussion about the implementation and the result. This is then followed by \textit{\nameref{propagation}} discussions. Lastly is there two sections about \textit{\nameref{sss}} and \textit{\nameref{methev}}.}

By looking at the results, of evaluating applications with and without WebTaint activated, do we for all four applications see a significant improvement. Stanford SecuriBench Micro have a 100\% prevention rate by using WebTaint, and the other three applications have 75.5\%, 75\%, and 73.3\%. Making the average across the four to be 81\%. It is a significant impact in combating integrity vulnerabilities. Further development implementing support for taint tracking of more data types could even increase this number.

However, gain in security might not be worth it if it comes with significant drawbacks as well. From the results can we see that using WebTaint adds a performance overhead. This overhead comes from instrumenting classes and the added operations to tracking taint. The most significant impact on time overhead comes from the instrumentation phase which can be seen in both Figure \ref{fig:Time}. The instrumentation happens the first time each class is loaded into the Java Virtual Machine. It means that applications with longer runtimes are less impacted by the added time overhead. It is seen by comparing the execution time of Avrora and Batika, 137.2\% respectively 432.2\%, with Tradebeans and Tradesoap, 26.3\% respectively 14.7\%.

Memory overhead tells a different story. The two most extended executions, together with almost every execution have the same memory overhead as the average which is 142.7\%. It is only the Eclipse, H2 and Jython DaCapo tests that have significantly less. It is hard to say why these are significantly less. One guess would be that they are significantly smaller in usage if Strings and therefore not affected by the added taint flag and help functions appended to the String, StringBuilder, and StringBuffer classes.

Both time and memory overhead could more than probably be optimized by reworking the implemented code to be more effective. This was however not conducted in this thesis because of time issues.

Acceptance of performance overhead is never a good idea if nothing good comes out of it. Though, an average prevention rate of 81\% is something that could make overhead acceptable to the system. By further optimizing the underlying logic and enhancing support for more data types would make the gain compared to the cost make it even more worth it. However, this could even after optimizations not be a possible use case for time and memory sensitive domains. It might even be possible to impair the user experience of a web application if the added time for events to happen takes a long time. An optimal solution for this might instead be not to use WebTaint as a security solution for the production service but instead use it on the staging server where flow tests of the servers are automatically run to test trigger any taint exceptions.



\section{Taint Tracking}
\label{propagation}
Due to time issue were only the classes String, StringBuilder and StringBuffer implemented to supports taint tracking. These are the most important classes for taint tracking when securing web applications since all inputs are once in the form of Strings. However, there is a risk of losing the tracking of taint since some libraries use char and byte arrays for String operations.

However, the results prove that the implemented classes do cause a significant difference. Nevertheless, the optimal solution would be with complete integration for all data types in Java. Just like Phosphor, but with the ability to sanitize variables.



\section{Sources, Sinks \& Sanitizers}
\label{sss}
One part of the thesis, believed in the beginning to be a minor part, was defining sources, sinks, and sanitizers. The implementation of taint trackers is heavily dependent on the defined sources, sinks, and sanitizers. Much work is needed in this area to define these correctly. However, since time was an issue, throughout this thesis, was the solution to aggregate definitions of sources, sinks, and sanitizers from the few works done by others. 

The optimal solution, however, would be extensive research where lists for each library, framework, and deployment utility commonly used by Java-based web applications was compiled. These lists could then be subscribed on depending on what type of application is used. Best case would be that every developer of Java libraries, frameworks, and deployment utilities compiled lists for their implementations.

Another thing of interest would be to introduce multiple taint types. It would be used to ensure data from sources to be sanitized with the correct sanitizer depending on the source or sink type. The reason behind this is because data from one source type might not be possible to sanitize with all types of sanitizers. It might also be that some sinks need a particular type of sanitation to work safely. 

The question of what to do when a taint exception gets caught is an interesting question. We believe that this depends a lot depending on the "mode" that the owner wants the application to execute in. For the "lightest" mode is logging sufficient. Telling what kind of taint exception occurred enables the application to get corrected at a later time. At a higher mode should an exception be thrown or predefined values used. This prevents the possible malicious user input to execute. 

The remedial action could even be to sanitize the data with a predefined sanitation function depending on the source or sink type. It could be as good as it is terrible. It could go two different ways. The first is that this would help prevent some vulnerabilities through automatic sanitation. The developer does than patch the problem by adding correct validation where it is missing. The second possibility is the same example except that the developer does not patch the problem. Also, maybe even lowers the ambition of correctly validating user input in future since the taint tracker can do some sanitization. We believe however that we are far away from implementing a taint tracker that is smart enough to take over the role of sanitizing user variables.



\section{Methodology of Evaluation}
\label{methev}
The thesis objective was from the beginning to implement the dynamic taint tracker, WebTaint, and benchmark it in comparison to Dynamic Security Taint Propagation and Phosphor. This was sadly not possible since the prior was not possible to build from the source files and Phosphor do not support sanitation of variables. Making the use case for Phosphor not applicable in comparison to the implemented taint tracker. It is hard to say how well the implemented tool performed when a comparison was not possible. However, the results prove that the implementation could be of use.