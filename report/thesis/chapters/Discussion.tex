\chapter{Discussion}
This chapter contains the discussions about the implemented Dynamic Taint Tracker and how well it performs. The chapter starts with a general presentation about the implementation. This follows by a section comparing it with \textit{\nameref{security}}. This is then followed by \textit{\nameref{sss}} discussions. Lastly is there two sections about \textit{\nameref{propagation}} and \textit{\nameref{methev}}.

From the results can we see that using the Dynamic Taint Tracker adds a performance overhead. This overhead comes from instrumenting the classes and from the added operations for tracking taint. The most significant impact on this, for time overhead, comes from the instrumentation which is seen in both Figure \ref{fig:Time}. The instrumentation is only done once which makes applications with longer runtime less impacted by the added time overhead. This is seen by comparing the execution time of Avrora and Batika, 137.2\% respectively 432.2\%, with Tradebeans and Tradesoap, 26.3\% respectively 14.7\%.

Memory overhead tells a different story. The two most extended executions here have about the same memory overhead as the average which is 142.7\%. For the memory overhead to be the same ratio for all applications is understandable since the added memory overhead comes from the jar file containing the instrumented rt.jar that is appended to the bootstrap classpath and from adding size to every String, StringBuilder and StringBuffer.

Both time and memory overhead could more than probably be optimized by reworking the implemented code to be more effective. This was however not conducted in this thesis because of time issues.

Acceptance of performance overhead is never a good idea if nothing good comes out of it. Though, an average prevention rate of 81\% is something that could make overhead acceptable to the system. By further optimizing the underlying logic and enhancing support for more data types would make the gain compared to the cost make it even more worth it. However, this could even after optimizations not be a possible use case for time and memory sensitive domains. It might even be possible to destroy the user experience of a web application if the added time for events to happen takes a long time.



\section{Domain-Driven Security}
\label{security}
As said prior, Domain-Driven security has been proven to mitigate Injection and Cross-Site Scripting attacks. By looking at the result of this thesis, can we also see that Dynamic Taint Tracking mitigates the same security vulnerabilities. Dynamic Taint Tracking is, however, compared to Domain-Driven, only an application that enforces validation of variables that have been in contact with untrusted sources. How they are validated does not matter as long as the method used is defined as a sanitizer by the Dynamic Taint Tracker. Domain-Driven Security, however, utilizes value primitives to secure validation and sanitation. They are a single point of validation which lowers the complexity of redefining or expanding the logic of the application. Dynamic Taint Propagation could be altered to enforce validations inside the value primitives constructors. It could work by altering all sanitizers to the only detaint when called from inside a value primitives constructor. It would force the user to use value primitives.



\section{Sources, Sinks, and Sanitizers}
\label{sss}
One part of the thesis that felt like a minor part before the actual conduction was defining sources, sinks, and sanitizers. This work could be a thesis in itself. The solution to this was to aggregate what could find others defining as sources, sinks, and sanitizers. It is however not an optimal solution. For a taint tracker to become widely used, do I believe that every service provider for Java applications and libraries should define the sources, sinks, and sanitizers in their implementation. The users could then subscribe on lists defining sources, sinks, and sanitizers depending on the application the tracker will analyze.

The question of what to do when a taint exception gets caught is an interesting question. I believe that this depends a lot depending on the "mode" that the owner wants the application to execute in. For the lightest mode is logging sufficient. Telling what kind of taint exception occurred enables the application to get corrected at a later time. At a higher mode should an exception be thrown or predefined values used. This prevents the possible malicious execution to execute. The remedial action could even be to sanitize the data with predefined sanitation functions. 

Another thing of interest would be to introduce multiple taint types. It could be used to ensure that data from sources sanitizes with the correct sanitizer depending on the source type. Since data from one type of source might not be harmful to all types of sinks and all types of sanitizers might not be possible to sanitize the data for all sinks correctly.



\section{Taint Tracking}
\label{propagation}
Due to time issue were only the classes String, StringBuilder and StringBuffer implemented to supports taint tracking. These are the most important classes for taint tracking when securing web applications since all inputs are once in the form of a String. However, there is a risk of losing the tracking of taint since some libraries use char och byte arrays to for string operations.

However, the results prove that for web applications do these classes cause a significant difference and taint tracking for them is still better than for none. Nevertheless, the optimal solution would be with complete integration of all Java data types. Just like Phosphor, but with the ability to sanitize variables.



\section{Methodology of Evaluation}
\label{methev}
The objective of the thesis was from the beginning to implement the Dynamic Taint Tracker and benchmark it in comparison to Dynamic Security Taint Propagation and Phosphor. This was sadly not possible since the first was not possible to build from the source files and Phosphor do not support sanitation of variables. Making the use case for Phosphor not applicable in comparison to the implemented taint tracker. It is hard to say how well the implemented tool performed when a comparison was not possible. However, the results prove that the implementation could be of use.