\chapter{Discussion}
\label{Discussion}
\textit{This chapter contains discussions regarding the implemented dynamic taint tracker, named WebTaint, and how well it performs. The chapter starts with a general discussion. This is then followed by \textit{\nameref{propagation}} discussions. The last two sections are \textit{\nameref{sss}} and \textit{\nameref{methev}}.}

By looking at the results in the previous chapter we see a clear indication of WebTaint's capability of detecting security vulnerabilities. Stanford SecuriBench Micro have a 100\% prevention rate by using WebTaint, and the other three applications have 75.5\%, 75\%, and 73.3\%. Making the average across the four to be 81\%. It is a significant impact in combating integrity vulnerabilities. The prevention rate could also be increased by the further development of the application where taint tracking support is enabled for charArrays and byteArrays which were not implemented due to time limitations during this thesis.

However, increase of in security might not be worth it if it comes with significant drawbacks. From the introduced overhead results can we see the usage of WebTaint adds overhead. This overhead comes from the Java Agent instrumenting the classes and the added operations to propagate taint. Application domains where time and memory usage is not a problem would not suffer from adding this overhead. However, web applications need fast response times to provide a good user experience for its users. Causing them to be time sensitive and therefore is WebTaint not suitable to be included in the production system.

The most significant impact on time overhead comes from the startup phase of the application where the Java Agent instruments class files. Instrumentation of a class file happens only once, and it is done the first time the Class Loader loads the files. This means that applications executing for a more extended period and reuses a smaller set of class files are less affected by the time overhead. It is seen in Figure \ref{fig:Time} where Avrora's and Batika's time overhead is 137.2\% respectively 432.2\% compared to Tradebeans and Tradesoaps 26.3\% respectively 14.7\%.

Memory overhead tells a different story. The two most extended executions, together with almost every execution have the same memory overhead as the average which is 142.7\%. It is only the Eclipse, H2 and Jython DaCapo tests that have significantly less. It is hard to say why these are significantly less. One guess would be that they are significantly smaller in the usage of Strings and therefore not affected by the added taint flag and help functions appended to the String, StringBuilder, and StringBuffer classes.



\section{Taint Propagation}
\label{propagation}
Due to time issue were only the classes String, StringBuilder and StringBuffer implemented to supports taint propagation. These are the most important classes for taint propagation when securing web applications since all inputs are once in the form of Strings. However, there is a risk of losing the tracking of taint since some libraries use Arrays and byteArrays for String operations.

Results prove that the implemented classes do cause a significant difference. Nevertheless, the optimal solution would be with complete integration for all data types in Java. Just like Phosphor, but with the ability to sanitize variables.



\section{Sources, Sinks \& Sanitizers}
\label{sss}
One part of the thesis, believed in the beginning to be a minor task, was defining sources, sinks, and sanitizers. The implementation of taint trackers is heavily dependent on these definitions, and much work is needed to define these correctly. However, since time was an issue, throughout this thesis, was the solution to compile definitions of sources, sinks, and sanitizers from the two sources found where the authors put together what they believed some of the sources, sinks, and sanitizers should be.

The optimal solution would be extensive research where lists for each library, framework, and deployment utility used by Java-based web applications was compiled. These lists could then be used depending on what functionality the implemented web application is using. Best case would be that every developer of Java libraries, frameworks, and deployment utilities compiled lists for their implementations.

Another thing of interest would be to introduce multiple taint types. It would be used to implement a more advanced taint propagation where data from a specific type of sources are sanitized with the correct type of sanitizer. This would remove the positivity of mistakenly using incorrect sanitizers and ensure better protection of WebTaint.



\section{Methodology of Evaluation}
\label{methev}
The thesis objective was from the beginning to implement a dynamic taint tracker and benchmark it in comparison to Dynamic Security Taint Propagation and Phosphor. This was sadly not possible since the prior was not possible to build from the source files and Phosphor do not support sanitation of variables. Making the use case for Phosphor not applicable in comparison to the implemented taint tracker. It is hard to say how well the implemented tool performed when a comparison was not possible. However, the results prove that the implementation could be of use.