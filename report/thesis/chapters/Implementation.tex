\chapter{Implementation}
This Chapter presents the fundamental parts in the process of implementing the Dynamic Taint Tracking tool. The chapter starts with a section describing the \textit{\nameref{Policies}} of the tool. This section is then followed by \textit{\nameref{SoftwareArchitecture}} and \textit{\nameref{NotableProblems}}.



\section{Policies}
\label{Policies}
The development of the Dynamic Taint Tracking tool relies on tainting, detainting, propagation logic and asserting negative taint. However, to implement the logic of the application need the security policies first be defined. Security policies are principles or actions that the application strives to fulfill \parencite{BayukJenniferL2012Cspg}. In the application developed in this thesis will these be based on two different aspects. These are \textit{confidentiality} and \textit{integrity}.



\subsection{Confidentiality}
The confidentiality policies entailed that data given to the user should only be data that the user have the right to access. This gives us the policy below.

\hfill
\begin{itemize}
    \item No information shall be released to users without permission.
\end{itemize}
\hfill

This entails that no information from sinks shall pass through a source unless it has the permission to do so.



\subsection{Integrity}
Integrity entails that users may not modify data which they do not have permission to alter. This gives us the policy below.

\hfill
\begin{itemize}
    \item No information shall be altered without permission.
\end{itemize}
\hfill

This entails that no information from sources shall gain access to a sink without first being sanitized.



\subsection{Taint Checking}
The policies above will be enforced by forcing validation of data that are or have been in contact with data coming from a source before they enter a sink. By enforcing this rule should preventions of confidentiality and integrity volubilities be reduced severely.

The policies above can also be combined with tainting policies. These are presented below.

\hfill
\begin{itemize}
    \item Data passing through sources going into the domain should be marked tainted.
    \item No tainted data is allowed to pass through a sink.
    \item Data can only be detainted through validation.
\end{itemize}
\hfill



\subsection{Taint Propagation}
To enable the tracking of taint in the system is a complete implementation of taint propagation needed. The ultimate goal would be to have support for propagation of taint for each class and data type. This is, however, a complex problem. Instrumentation of classes is decently, but instrumentation of primitives and arrays is a rather complex problem. However, the principal behind the propagation is the same for all data types. 

Below are rules defining when taint variables should propagate.

\hfill
\begin{itemize}
    \item Data resulting in a copy, subset or combination.
    \item Data disclosing information about tainted data.
\end{itemize}
\hfill



\section{Sources, Sinks \& Sanitizers}
Defining the source, sinks, and sanitizers is a large task in itself. There is no official documentation in Java specifying these and depending on the application, framework and library used might this vary a lot.  The sources, sinks and sanitizers used in this thesis is an aggregation from \textcite{sssCodeMaster} and \textcite{sssOWASP}. These web pages present sources, sinks, and sanitizers from their experience with developing web applications. 



\section{Software Architecture}
\label{SoftwareArchitecture}
The implementation of the Dynamic Taint Tracking tool is divided into three subprojects. These three are Agent, Xboot, and Utils. 

\hfill
\begin{description}
    \item[Agent] Project that transforms classes loaded at runtime into sources, sinks or sanitizers.
    \item[Xboot] Project that loops through all classes in rt.jar and transforms into sources, sinks or sanitizers.
    \item[Utils] Utilities to transform classes into sources, sinks, and sanitizers. 
\end{description}
\hfill

The reasoning behind the division is because of the need of transforming classes both before runtime and during runtime. The Agent is handling the transformation in runtime and Xboot transforms classes on command before runtime. The logic of transforming the classes is, however, the same in both projects. Therefore, to remove duplications of code is al logic of transforming classes extracted from Xboot and Agent and placed into the Utils project.

The implemented Dynamic Taint Tracking tool supports propagation of taint for the classes: String, StringBuilder and StringBuffer. The goal was to implement propagation for all classes. This, however, took more time than expected.



\subsection{The Utils Project}
The Utils project includes the core logic of marking methods and classes as sources, sinks, and sanitizers. It works by taking a class as an argument that is to be checked if it qualifies for any of the three below criteria.

\hfill
\begin{itemize}
    \item Is same class as the defined source, sink or sanitizer.
    \item Implements interface of the defined source, sink or sanitizer.
    \item Extends defined source, sink or sanitizer class (recursive call. Checks all in the list for each extended class). 
\end{itemize}
\hfill

If a class fulfills any of the three criteria will the list of defined method correlating to either source, sinks or sanitizer be used, and instrumentation of the methods will be conducted.

The instrumentation of the method works differently depending on if it is a source, sink or sanitizer. Where instrumentation of sources will set the return parameter of the method as tainted. Instrumentation of sanitizers works by detainting the return value of the method. For sinks will an assertion check the value of the taint, if it is tainted is an error thrown.



\section{Notable Problems}
\label{NotableProblems}
One of the first problems that were introduced during the development of the application was that some classes could not be instrumented during runtime. More precisely, the classes that the Java Virtual Machine relies on can't be instrumented at runtime. However, there is a solution to this. The solution is to pre-instrument the Java Runtime Environment and create a JAR file with statically modified versions of the classes. The created JAR file is then loaded through the option \textit{Xbootclasspath/p} that appends the JAR file to the front of the bootstrap classpath. Making the Java Virtual Machine use our modified versions of the Java Runtime Environment \parencite{xboot} before the original version. Because of this limitation was the decision of instrumenting all classes in the JRE statically beforehand made.

Another problem is that instrumentation of primitives and arrays not possible. This causes a problem since it opens the ability to miss propagation of tainted data if they ever pass through a byte- or char array. The solution that can solve this is to create shadow as \textcite{BellJ.2014PIdd} did while creating Phosphor \parencite{phosphor}. 

Another problem that emerged was that operations with primitives are direct bytecode translations. Two examples of these are the usage of + (addition) and - (subtraction). Adding operations to these through Javassist's source level API is therefore not possible. To solve this are operations on bytecode level needed and Javassist, bytecode level API, is suitable for this. \parencite{Javassist} 
