\chapter{Implementation}
This Chapter presents the fundamental parts of the implementation process of the Dynamic Taint Tracker. The chapter starts with a section describing \textit{\nameref{Policies}} enforced by the application. This section is then followed by \textit{\nameref{SoftwareArchitecture}}.



\section{Policies}
\label{Policies}
The development of the Dynamic Taint Tracker relies on the tasks described in Table \ref{table:taintTracking}. These are tainting, detainting, propagating taint, and assert non-tainted. However, to implement the logic need security policies first be defined. Security policies are principles or actions that the application strives to fulfill \parencite{BayukJenniferL2012Cspg}. The taint tracker developed in this thesis will base on two different aspects. These are \textit{confidentiality} and \textit{integrity}.



\subsection{Confidentiality}
The confidentiality policy defines that data given to the user should only be data that the user have the right to access. The goal is to ensure prevention of malicious usage of applications where attackers aim to steal application data. This gives us the policy:

\begin{itemize}
    \item No information shall be released to users without the user having the correct permission for the information.
\end{itemize}
\hfill

This entails that no information from sinks shall pass through a source unless it has the permission to do so.



\subsection{Integrity}
The integrity policy defines that users may not modify data which they do not have permission to alter. This goal is to ensure prevention of malicious usage of the application where attackers aim to destroy application data. This gives us the policy:

\begin{itemize}
    \item No information shall be altered without the users having permission to do so for the information.
\end{itemize}
\hfill

This entails that no information from sources shall pass through a sink without first being sanitized.



\subsection{Taint Checking}
The policies above are enforced through validation of user input from sources and any data it has come in contact with. By enforcing these should preventions of confidentiality and integrity volubilities be reduced severely.

The policies above can be translated into taint policies. These are:

\begin{itemize}
    \item Data passing through sources, going into the domain, shall always be marked tainted.
    \item Tainted data is never allowed to pass through sinks.
    \item Predefined sanitizers are the only method calls allowed to detaint data.
\end{itemize}
\hfill



\subsection{Taint Tracking}
To enable the tracking of taint in the system is a complete implementation of taint tracking needed. The ultimate goal would be to have support for tracking of taint for each class and data type. This is, however, a complex problem. Instrumentation of classes is decently, but instrumentation of primitives and arrays is a rather complex problem. However, the principal behind the tracking is the same for all data types. 

Below are rules defining when taint variables should propagate.

\begin{itemize}
    \item Data resulting in a copy, subset or combination.
    \item Data disclosing information about tainted data.
\end{itemize}
\hfill



\section{Sources, Sinks \& Sanitizers}
Defining the source, sinks, and sanitizers is a large task in itself. There is no official documentation in Java specifying these and depending on the application, framework and library used might this vary a lot.  The sources, sinks and sanitizers used in this thesis is an aggregation from \textcite{sssCodeMaster} and \textcite{sssOWASP}. These web pages present sources, sinks, and sanitizers from their experience with developing web applications. 



\section{Software Implementation}
\label{SoftwareArchitecture}
The implementation of the Dynamic Taint Tracker is divided into three subprojects. These three are Agent, Xboot, and Utils. 

\begin{description}
    \item[Agent] Project that transforms classes loaded at runtime into sources, sinks or sanitizers.
    \item[Xboot] Project that loops through all classes in rt.jar and transforms into sources, sinks or sanitizers.
    \item[Utils] Utilities to transform classes into sources, sinks, and sanitizers. 
\end{description}
\hfill

The reasoning behind the division is because of the need of transforming classes both before runtime and during runtime. The Agent is handling the transformation in runtime and Xboot transforms classes on command before runtime. The logic of transforming the classes is, however, the same in both projects. Therefore, to remove duplications of code is al logic of transforming classes extracted from Xboot and Agent and placed into the Utils project.

The implemented Dynamic Taint Tracker supports tracking of taint for the classes: String, StringBuilder and StringBuffer. The goal was to implement tracking for all classes. However, this took more time than expected.



\subsection{The Utils Project}
The Utils project includes the core logic of marking methods and classes as sources, sinks, and sanitizers. It works by taking a class as an argument that is to be checked if it qualifies for any of the three below criteria.

\begin{itemize}
    \item Is same class as the defined source, sink or sanitizer.
    \item Implements interface of the defined source, sink or sanitizer.
    \item Extends defined source, sink or sanitizer class (recursive call. Checks all in the list for each extended class). 
\end{itemize}
\hfill

If a class fulfills any of the three criteria will the list of defined method correlating to either source, sinks or sanitizer be used, and instrumentation of the methods will be conducted.

The instrumentation of the method works differently depending on if it is a source, sink or sanitizer. Where instrumentation of sources will set the return parameter of the method as tainted. Instrumentation of sanitizers works by detainting the return value of the method. For sinks will an assertion call check that none of the parameters are tainted. If anyone of them is, then a taint exception occurs, and the remedial action of changing the value to a predefined value, where the value is an empty string, and logging the event used.

should conduct. This action should be, depending on options, a logging event, throwing an error or modifying the tainted value into a safe predefined value. During the conducted benchmarking is the option of a predefined value, where the value is an empty string, and logging the event used.



\subsection{Notable Problems}
\label{NotableProblems}
One of the first problems that were introduced during the development of the application was that some classes could not be instrumented during runtime. More precisely, the classes that the Java Virtual Machine relies on can't be instrumented at runtime. However, there is a solution to this. The solution is to pre-instrument the base Java Runtime Environment and create a new instrumented rt.jar file with statically modified versions of the classes. The created jar file loads through the option \textit{Xbootclasspath/p} that appends the file to the front of the bootstrap classpath. Making the Java Virtual Machine use our modified versions of the base Java Runtime Environment \parencite{xboot} before the original version.

Another problem is that instrumentation of primitives and arrays not possible. This causes a problem since it opens the ability to miss tracking of tainted data if they ever pass through a byte- or char array. The solution that can solve this is to create shadow as \textcite{BellJ.2014PIdd} did while creating Phosphor \parencite{phosphor}. 

Another problem that emerged was that operations with primitives are direct bytecode translations. Two examples of these are the usage of + (addition) and - (subtraction). Adding operations to these through Javassist's source level API is therefore not possible. To solve this are operations on bytecode level needed and Javassist, bytecode level API, is suitable for this. \parencite{Javassist} 
