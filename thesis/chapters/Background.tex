\chapter{Background}


\section{Security Vulnerabilities}
The organization Open Web Applications Security Project, mostly known for its shortening (OWASP) \parencite{OpenWebApplicationSecurityProject}, produces yearly a top 10 security risks. The report contains information about the ten most common application security risks that for the current year. Information such as how the security risk is exploited and possible prevention method is also presented. \parencite{OWASP2017} This report will look at the number one and eight security risks of 2017 which is injection attacks and cross-site scripting. \parencite{OWASP2017}


\subsection{Injection}
The most common security risk is Injection Attacks. \parencite{OWASP2017} A Injection Attack is any attack where the attacker's input changes the intent of the execution and executes malicious code. Common result of Injection Attacks are file destruction, lack of accountability, denial of access and data loss. \parencite{Secure_Web} 

There is two kinds of different Injection Attacks. These two are SQL Injection and Blind SQL Injection. \parencite{Secure_Web} Both will be described below.


\subsubsection{SQL Injection}


\subsubsection{Blind SQL Injection}


\subsection{Cross-site Scripting}


\section{Taint Propagation}
Taint propagation, also known as taint analysis and taint checking [SOURCE NEEDED?], is a tool to analyse the flow of information in a domain. \parencite{Pan2015} It works by giving input data a tainted property which follows the data and propagate onto other data which it is in contact with. The taint property is later checked in security sensitive sinks. \parencite{Pan2015} 

Perl and Ruby are two programming languages which have adapted to user dynamic taint checking. \parencite{perl, ruby} And there are some tools who enables taint checking for other languages such as TaintDroid \parencite{Ma2010} and FlexTaint \parencite{Venkataramani2008}.

Two of OWASP top 10 application security risks of 2017 is Injection and Cross-Site Scripting (XSS). \parencite{OWASP2017} Protection against these two attacks are best done by validating input data which taint propagation reminds and forces the developer to do.


\section{Domain Driven Design}
There exists a plethora of tools who aim to help in the process of developing complex domain models, but Domain Driven Design (DDD) is not one if them. \parencite{Bankes, 10.1007/978-3-319-24309-2_33} DDD is more of a thought process and methodology to follow every step of the process. \parencite{EvansEric2004Dd:t} In \emph{Domain-driven design reference: definitions and patterns summaries} do \textcite{evans_2015} describe DDD trough three core ideas:

\begin{itemize}
  \item Focus on the core domain.
  \item Explore models in a creative collaboration of domain practitioners and software practitioners.
  \item Speak a ubiquitous language within an explicitly bounded context.
\end{itemize}

The core domain is the part of your product that is most important and often is your main selling point compared to other similar products. \parencite{millett_2015} A discussion and even possible a documentation describing the core domain is something that will help the development of the product. The idea is to keep everybody on the same track heading in the same direction. \parencite{EvansEric2004Dd:t}

The second idea is to explore and develop every model in collaboration between domain practitioners, who are experts in the given domain, and software developers. This ensures that important knowledge needed to successfully develope the product is communicated back and forth between the two parties. \parencite{millett_2015} The third idea is important to enable and streamline the second. By using a ubiquitous language will miscommunication between domain and software practitioners be minimized and the collaboration between the two parties can instead focus on the important parts which is to develop the product. \parencite{evans_2015}

\textcite{evans_2015} do as well argue about the weight of clearly defining the bounded contexts for each defined model, and this needs to be done in the ubiquitous language created for the specific product. The need of this exists because of the otherwise great risk of misunderstandings and erroneous assumptions in the collaborations between the different models. \parencite{millett_2015}


\subsection{Domain Driven Security}
\textcite{Wilander2009, Johnsson2009} created 2009 a blog post each in a synchronous manner where they together introduces the concept of Domain Driven Security (DDS) to the public. They describe DDS as the intersection between Domain Driven Deign (DDD) and application security. DDD is about developing complex domain models and one of the most basic rule of application security is to always validate input data. DDS in other hand, is about the importance of creating and maintaining domain models who are reflecting the product correctly and they are validated so they cant be populated with erroneous data. \parencite{Wilander2009, Johnsson2009, Arnor2016, Stendahl2016} 