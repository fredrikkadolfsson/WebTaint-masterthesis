\chapter{Background}
% Studenten visar kännedom om teoretisk bakgrund och tidigare utfört arbete (betydande litteratur nämns och relevant material används).
% Bakgrunden är sammanhängande och relevant.
This Chapter will present some background knowledge with needed information to comprehend the chapters to follow. The chapters starts with a generally description about how a \textit{web application} work which then is followed by a section with two of the most common \textit{security vulnerabilities} to a web application. After that is there a chapter describing \textit{Dynamic Taint Propagation} and one describing \textit{Domain Driven Security}. The last section in the chapter is about \textit{JVM bytecode manipulation}.


\section{Web Application}
To make applications available for a large set off people and make te application accessible from now days almost everywhere do businesses deploy their applications to the web. They deployment of an application can vary a lot but the most common architectural structure for a web application is based on three tiers. The first is the presentation tire which is the visual components rendered by a browser. The second is the logic tire which can be seen as the brain of the application. The last and third is the storage tier, where the second tier can store data as needed. \parencite{JustinClarke-Salt2009SIAa} Figure \ref{fig:webApplication-Haldar} illustrates this structure.

\begin{figure}
  \centering
  \includegraphics[width=\textwidth]{images/webApplication-Haldar.png}
  \caption{Web application structure \cite{Haldar}.}
  \label{fig:webApplication-Haldar}
\end{figure}

As can be seen in picture \ref{fig:webApplication-Haldar} dose the tiers only communicate with the tire closest to itself. This causes the second tire to become a safe guard for the tire three where the valuable information for a attacker lies. The storage tier contains all the information the application needs to provide the wanted service. Such information might for example be name, email, personal number and credit card information. \parencite{JustinClarke-Salt2009SIAa}

\section{Security Vulnerabilities}
The organization Open Web Applications Security Project, mostly known for its shortening (OWASP), is a online community which aim to help to secure web applications. \parencite{OpenWebApplicationSecurityProject} OWASP produces a report about the top 10 security risks with a web application. The report contains information about the ten most common application security risks that for the current year. Information such as how the security risk is exploited and possible prevention method is also presented. \parencite{OWASP2017} This report will look at the number one and eight security risks of 2017 which is injection attacks and cross-site scripting. \parencite{OWASP2017}


\subsection{Injection}
The most common security risk is Injection Attacks. \parencite{OWASP2017} A Injection Attack is any attack where the attacker's input changes the intent of the execution and executes malicious code. Common result of Injection Attacks are file destruction, lack of accountability, denial of access and data loss. \parencite{Secure_Web}

There is two kinds of different Injection Attacks. These two are SQL Injection and Blind SQL Injection. \parencite{Secure_Web} Both will be described below.


\subsubsection{SQL Injection}
SQL Injection is when a SQL query is tampered with which then results in gaining data from the database which were not intended. Listing \ref{lst:acceptable_to_SQL_Injection} displays a possible SQL Query which is open to SQL Injections. This is due to the fact that the variable UserId is never validated before it is being used to query the database. \parencite{JustinClarke-Salt2009SIAa, Secure_Web} 

\hfill
\begin{lstlisting}[
  language=SQL,
  caption=Code Acceptable to SQL Injection,
  label={lst:acceptable_to_SQL_Injection}]
userId = (*@\textit{userInput}@*)
"SELECT * FROM Users WHERE userId = " + userId
\end{lstlisting}
\hfill

The query will work as intended as long as the user input, notated with \textit{userInput}, only is a user id. But what happens if the user input is \textit{10 or 1 = 1}? This user input would result in the query seen in listing \ref{lst:SQL_Injection}.

\hfill
\begin{lstlisting}[
  language=SQL,
  caption=SQL Injection,
  label={lst:SQL_Injection}]
SELECT * FROM Users WHERE userId = 10 or 1 = 1
\end{lstlisting}
\hfill

This query would result in that the database returns the whole table of users sins the second or parameter is always true. This problem can be prevented in a couple of different ways. The first is through validation of the input. In our example do we expect the input to be a Integer. By verifying that the input as seen in listing \ref{lst:SQL_Injection_Verified} can we protect the query from being injected with unwanted commands.

\hfill
\begin{lstlisting}[
  language=SQL,
  caption=Preventing SQL Injection through Verification,
  label={lst:SQL_Injection_Verified}]
userId = (*@\textit{userInput}@*)
isInteger(userId)
"SELECT * FROM Users WHERE userId = " + userId
\end{lstlisting}
\hfill

A second more common alternative is to use SQL Parameters which handles the verification for the user. This leaves the verification and validation of input up to the SQL engine. Our example written with SQL Parameters can be seen in listing \ref{lst:SQL_Injection_Parameters}.

\hfill
\begin{lstlisting}[
  language=SQL,
  caption=Preventing SQL Injection through SQL Parameters,
  label={lst:SQL_Injection_Parameters}]
userId = (*@\textit{userInput}@*)
sqlQuery = "SELECT * FROM Users WHERE userId = @0"
db.Execute(sqlQuery, userId)
\end{lstlisting}
\hfill


\subsubsection{Blind SQL Injection}
Blind SQL Injection is very similar to SQL Injection. The only difference is that that attacker dose not receive the wanted information from the database. The information is instead received by monitoring variables such as how long time the response took or what kind of error messages it returns. A example of the first is to create a Blind SQL Injection where the query tells the SQL engine to sleep depending on a condition a example of this can be seen in listing \ref{lst:Blind_SQL_Injection_Time}. \parencite{JustinClarke-Salt2009SIAa, Secure_Web} 

\hfill
\begin{lstlisting}[
  language=SQL,
  caption=Time Based Blind SQL Injection,
  label={lst:Blind_SQL_Injection_Time},
  xleftmargin=-1cm]
SELECT * FROM Users WHERE userId = 1 WAITFOR DELAY '0:0:5'
\end{lstlisting}
\hfill

The second variant of Blind SQL Injection is by analyzing the error messages and depending on what they return build a image off the wanted answer. \parencite{JustinClarke-Salt2009SIAa, Secure_Web} 


\subsection{Cross-site Scripting}
Cross-Site Scripting (XSS) have been a vulnerability since the beginning of the internet. One of the first XSS attacks created just after the release of JavaScript. The attack was passible by loading another website into a frame on the site that the attacker controls. The attacker could then through JavaScript access any content that is visible or typed into the loaded frame. To prevent this from being possible were the standard of Same-Origin Policy which restricted JavaScript to only access content on its own origin. \parencite{FogieSeth2007Xacs, w3csop}

But the introduction of the Same-Origin Policy did not stop the attackers from preforming XSS attacks. The next wave of attacks were mostly towards chat roms where it was possible to inject JavaScript tags into the input of the message. Which would then later be reflected by the server itself, when displaying the message for other users, and thereby bypassing the Same-Origin Policy. \parencite{FogieSeth2007Xacs}

\textbf{Reflected vs Persistent}


\section{Dynamic Taint Propagation}
Taint propagation, also known as taint analysis and taint checking [SOURCE NEEDED?], is a tool to analyse the flow of information in a domain. \parencite{Pan2015} It works by giving input data a tainted property which follows the data and propagate onto other data which it is in contact with. The taint property is later checked in security sensitive sinks. \parencite{Pan2015}

Perl and Ruby are two programming languages which have adapted to user dynamic taint checking. \parencite{perl, ruby} And there are some tools who enables taint checking for other languages such as TaintDroid \parencite{Ma2010} and FlexTaint \parencite{Venkataramani2008}.

Two of OWASP top 10 application security risks of 2017 is Injection and Cross-Site Scripting (XSS). \parencite{OWASP2017} Protection against these two attacks are best done by validating input data which taint propagation reminds and forces the developer to do.


\section{Domain Driven Security}
There exists a plethora of tools who aim to help in the process of developing complex domain models, but Domain Driven Design (DDD) is not one if them. \parencite{Bankes, 10.1007/978-3-319-24309-2_33} DDD is more of a thought process and methodology to follow every step of the process. \parencite{EvansEric2004Dd:t} In \emph{Domain-driven design reference: definitions and patterns summaries} do \textcite{evans_2015} describe DDD through three core ideas:

\begin{itemize}
  \item Focus on the core domain.
  \item Explore models in a creative collaboration of domain practitioners and software practitioners.
  \item Speak a ubiquitous language within an explicitly bounded context.
\end{itemize}

The core domain is the part of your product that is most important and often is your main selling point compared to other similar products. \parencite{millett_2015} A discussion and even possible a documentation describing the core domain is something that will help the development of the product. The idea is to keep everybody on the same track heading in the same direction. \parencite{EvansEric2004Dd:t}

The second idea is to explore and develop every model in collaboration between domain practitioners, who are experts in the given domain, and software developers. This ensures that important knowledge needed to successfully develope the product is communicated back and forth between the two parties. \parencite{millett_2015} The third idea is important to enable and streamline the second. By using a ubiquitous language will miscommunication between domain and software practitioners be minimized and the collaboration between the two parties can instead focus on the important parts which is to develop the product. \parencite{evans_2015}

\textcite{evans_2015} do as well argue about the weight of clearly defining the bounded contexts for each defined model, and this needs to be done in the ubiquitous language created for the specific product. The need of this exists because of the otherwise great risk of misunderstandings and erroneous assumptions in the collaborations between the different models. \parencite{millett_2015}

\textcite{Wilander2009, Johnsson2009} created 2009 a blog post each in a synchronous manner where they together introduces the concept of Domain Driven Security (DDS) to the public. They describe DDS as the intersection between Domain Driven Deign (DDD) and application security. DDD is about developing complex domain models and one of the most basic rule of application security is to always validate input data. DDS in other hand, is about the importance of creating and maintaining domain models who are reflecting the product correctly and they are validated so they cant be populated with erroneous data. \parencite{Wilander2009, Johnsson2009, Arnor2016, Stendahl2016}


\section{JVM Bytecode Manipulation}


\subsection{Javassist}

